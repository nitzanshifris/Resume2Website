"use client"

import { WavyBackground } from "@/components/ui/wavy-background"
import { TracingBeam } from "@/components/ui/tracing-beam"
import { Download, Loader2 } from "lucide-react"
import { Button } from "@/components/ui/button"
import { motion, AnimatePresence } from "framer-motion"
import { useState, useEffect } from "react"
import { useFontSize } from "@/contexts/font-size-context"
import { FontSizeSelector } from "@/components/ui/font-size-selector"
import { cn } from "@/lib/utils"
import { WatermarkToggle } from "@/components/watermark-toggle"
import { useWatermark } from "@/contexts/watermark-context"
import { SectionControls } from "@/components/section-controls"
import { ExportButton } from "@/components/export-button"
import { mapCvDataToSections } from "@/lib/data-mapper"
import { fetchLatestCVData, getSessionId } from "@/lib/cv-data-adapter"

// Import injected CV data if available (generated by portfolio generator)
let injectedPortfolioData = null
let useRealData = false
try {
  const injectedModule = require("@/lib/injected-data")
  injectedPortfolioData = injectedModule.portfolioData
  useRealData = injectedModule.useRealData
} catch (e) {
  // No injected data available, will use API or demo data
}
import { FloatingNav } from "@/components/ui/floating-nav"
import { useTheme } from "@/contexts/theme-context"
import { ThemeSelector } from "@/components/ui/theme-selector"
import { TextGenerateEffect } from "@/components/ui/text-generate-effect"
import { AnimatedSubtitle } from "@/components/ui/animated-subtitle"
import { MovingBorder } from "@/components/ui/moving-border"
import { DndContext, closestCenter, KeyboardSensor, PointerSensor, useSensor, useSensors, DragEndEvent } from "@dnd-kit/core"
import { arrayMove, SortableContext, sortableKeyboardCoordinates, verticalListSortingStrategy } from "@dnd-kit/sortable"
import { EditModeToggle } from "@/components/edit-mode-toggle"
import { useEditMode } from "@/contexts/edit-mode-context"
import { ThemeToggle } from "@/components/theme-toggle"
import { DraggableSection } from "@/components/draggable-section"
import { EditableText } from "@/components/ui/editable-text"
import { AdvancedProfileEditor } from "@/components/ui/advanced-profile-editor"
import { EditableAvailability } from "@/components/ui/editable-availability"
import { downloadCV } from "@/lib/download-cv"
import { useToast } from "@/components/ui/use-toast"

// Import section components
import { ParagraphSection } from "@/components/sections/paragraph-section"
import { SkillsSection } from "@/components/sections/skills-section"
import { TimelineSection } from "@/components/sections/timeline-section"
import { ProjectsSection } from "@/components/sections/projects-section"
import { PublicationsSection } from "@/components/sections/publications-section"
import { AccomplishmentsSection } from "@/components/sections/accomplishments-section"
import { ContactSection } from "@/components/sections/contact-section"
import { CertificationsSection } from "@/components/sections/certifications-section"
import { HobbiesSection } from "@/components/sections/hobbies-section"
import { LanguagesSection } from "@/components/sections/languages-section"
// Import new section components
import { CoursesSection } from "@/components/sections/courses-section"
import { MembershipsSection } from "@/components/sections/memberships-section"
import { PatentsSection } from "@/components/sections/patents-section"
import { ColorModeToggle } from "@/components/color-mode-toggle"

const sectionComponentMap = {
  paragraph: ParagraphSection,
  bento: SkillsSection,
  timeline: TimelineSection,
  projects: ProjectsSection,
  publications: PublicationsSection,
  accomplishments: AccomplishmentsSection,
  contact: ContactSection,
  certifications: CertificationsSection,
  hobbies: HobbiesSection,
  languages: LanguagesSection,
  // Add new components to the map
  courses: CoursesSection,
  memberships: MembershipsSection,
  patents: PatentsSection,
}

const heroContainerVariants = {
  hidden: { opacity: 0 },
  visible: {
    opacity: 1,
    transition: {
      staggerChildren: 0.3,
      delayChildren: 0.5,
    },
  },
}

const heroItemVariants = {
  hidden: { y: 20, opacity: 0 },
  visible: {
    y: 0,
    opacity: 1,
    transition: {
      duration: 0.7,
      ease: "easeOut",
    },
  },
}

const heroTitleVariants = {
  hidden: { 
    y: 30, 
    opacity: 0,
    scale: 0.9,
    filter: "blur(10px)"
  },
  visible: {
    y: 0,
    opacity: 1,
    scale: 1,
    filter: "blur(0px)",
    transition: {
      duration: 1.2,
      ease: [0.16, 1, 0.3, 1], // Smooth easing
      delay: 0.3
    },
  },
}

export default function PortfolioPage() {
  const { getSizeClasses } = useFontSize()
  const { wavyColors, theme } = useTheme()
  const { isEditMode } = useEditMode()
  const { isWatermarkVisible, toggleWatermark } = useWatermark()
  
  // Initialize with demo data immediately (like v1.5 does)
  const [portfolioData, setPortfolioData] = useState(() => {
    // Check for injected data first
    if (injectedPortfolioData && useRealData) {
      console.log('Using injected CV data')
      return injectedPortfolioData
    }
    
    // Load demo data synchronously 
    try {
      const demoData = require("@/app/resume-data.json")
      return mapCvDataToSections(demoData)
    } catch {
      return null
    }
  })
  
  const [sectionsOrder, setSectionsOrder] = useState(() => {
    // Check for injected data first
    if (injectedPortfolioData && useRealData) {
      return injectedPortfolioData.sections?.map(s => s.id) || []
    }
    
    // Initialize sections order from demo data
    try {
      const demoData = require("@/app/resume-data.json")
      const mapped = mapCvDataToSections(demoData)
      return mapped.sections?.map(s => s.id) || []
    } catch {
      return []
    }
  })
  
  const [sectionVisibility, setSectionVisibility] = useState(() => {
    // Check for injected data first
    if (injectedPortfolioData && useRealData) {
      const visibility = {}
      injectedPortfolioData.sections?.forEach(section => {
        visibility[section.id] = true
      })
      return visibility
    }
    
    // Initialize section visibility from demo data
    try {
      const demoData = require("@/app/resume-data.json")
      const mapped = mapCvDataToSections(demoData)
      const visibility = {}
      mapped.sections?.forEach(section => {
        visibility[section.id] = true
      })
      return visibility
    } catch {
      return {}
    }
  })
  
  const [heroData, setHeroData] = useState(() => {
    // Check for injected data first
    if (injectedPortfolioData && useRealData) {
      return injectedPortfolioData.hero || {
        name: "Your Name",
        title: "Your Title",
        tagline: "Your Tagline",
        availability: "Available for opportunities",
        profilePhotoUrl: null,
        profilePhotoSettings: {
          shape: 'circle' as const,
          zoom: 1,
          offsetX: 0,  
          offsetY: 0
        }
      }
    }
    
    // Initialize hero data from demo data
    try {
      const demoData = require("@/app/resume-data.json")
      const mapped = mapCvDataToSections(demoData)
      return mapped.hero || {
        name: "RAN LOTAN",
        title: "System Engineer",
        tagline: "Your Tagline",
        availability: "Available for opportunities",
        profilePhotoUrl: null,
        profilePhotoSettings: {
          shape: 'circle' as const,
          zoom: 1,
          offsetX: 0,  
          offsetY: 0
        }
      }
    } catch {
      return {
        name: "RAN LOTAN",
        title: "System Engineer",
        tagline: "Your Tagline",
        availability: "Available for opportunities",
        profilePhotoUrl: null,
        profilePhotoSettings: {
          shape: 'circle' as const,
          zoom: 1,
          offsetX: 0,
          offsetY: 0
        }
      }
    }
  })
  
  const [isLoading, setIsLoading] = useState(false) // Start with false since we have demo data
  const [activeSection, setActiveSection] = useState("")

  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    }),
  )

  const navItems =
    sectionsOrder
      .map((sectionId) => portfolioData?.sections.find((s) => s.id === sectionId))
      .filter((section) => section && sectionVisibility[section.id])
      .map((section) => ({
        name: section.title,
        link: `#${section.id}`,
      })) || []

  // Get theme-specific gradient classes
  const getHeroGradientClasses = () => {
    switch (theme) {
      case "purple":
        return {
          gradient: "dark:from-purple-400 dark:via-pink-400 dark:to-blue-400 from-purple-600 via-pink-600 to-blue-600",
          glow: "from-purple-400/30 via-pink-400/30 to-blue-400/30 dark:from-purple-400/30 dark:via-pink-400/30 dark:to-blue-400/30 light:from-purple-500/20 light:via-pink-500/20 light:to-blue-500/20",
          shadow: "[text-shadow:0_4px_12px_rgba(147,51,234,0.25)]",
          buttonGradient: "from-purple-600 to-pink-600",
          buttonGlow: "from-purple-600 to-pink-600"
        }
      case "blue":
        return {
          gradient: "dark:from-blue-400 dark:via-cyan-400 dark:to-teal-400 from-blue-600 via-cyan-600 to-teal-600",
          glow: "from-blue-400/30 via-cyan-400/30 to-teal-400/30 dark:from-blue-400/30 dark:via-cyan-400/30 dark:to-teal-400/30 light:from-blue-500/20 light:via-cyan-500/20 light:to-teal-500/20",
          shadow: "[text-shadow:0_4px_12px_rgba(59,130,246,0.25)]",
          buttonGradient: "from-blue-600 to-cyan-600",
          buttonGlow: "from-blue-600 to-cyan-600"
        }
      case "green":
        return {
          gradient: "dark:from-green-400 dark:via-emerald-400 dark:to-teal-400 from-green-600 via-emerald-600 to-teal-600",
          glow: "from-green-400/30 via-emerald-400/30 to-teal-400/30 dark:from-green-400/30 dark:via-emerald-400/30 dark:to-teal-400/30 light:from-green-500/20 light:via-emerald-500/20 light:to-teal-500/20",
          shadow: "[text-shadow:0_4px_12px_rgba(34,197,94,0.25)]",
          buttonGradient: "from-green-600 to-emerald-600",
          buttonGlow: "from-green-600 to-emerald-600"
        }
      case "orange":
        return {
          gradient: "dark:from-orange-400 dark:via-red-400 dark:to-pink-400 from-orange-600 via-red-600 to-pink-600",
          glow: "from-orange-400/30 via-red-400/30 to-pink-400/30 dark:from-orange-400/30 dark:via-red-400/30 dark:to-pink-400/30 light:from-orange-500/20 light:via-red-500/20 light:to-pink-500/20",
          shadow: "[text-shadow:0_4px_12px_rgba(249,115,22,0.25)]",
          buttonGradient: "from-orange-600 to-red-600",
          buttonGlow: "from-orange-600 to-red-600"
        }
      default:
        return {
          gradient: "dark:from-purple-400 dark:via-pink-400 dark:to-blue-400 from-purple-600 via-pink-600 to-blue-600",
          glow: "from-purple-400/30 via-pink-400/30 to-blue-400/30 dark:from-purple-400/30 dark:via-pink-400/30 dark:to-blue-400/30 light:from-purple-500/20 light:via-pink-500/20 light:to-blue-500/20",
          shadow: "[text-shadow:0_4px_12px_rgba(147,51,234,0.25)]",
          buttonGradient: "from-purple-600 to-pink-600",
          buttonGlow: "from-purple-600 to-pink-600"
        }
    }
  }

  const heroGradientClasses = getHeroGradientClasses()

  // Data loading effect - copy exact pattern from v1.5
  useEffect(() => {
    const loadCVData = async () => {
      try {
        setIsLoading(true)
        
        // Check if we're in standalone mode (same logic as v1.5)
        const isStandalone = window.location.port === '3232' || window.location.port === '3000' || window.location.port === '3001'
        
        if (isStandalone) {
          console.log('ðŸŽ¨ Running in standalone mode with demo data')
          // Demo data is already loaded in state initialization - no need to do anything
        } else {
          // For generated portfolios, always fetch CV data
          console.log('ðŸ”„ Loading CV data...')
          try {
            const response = await fetch('/api/resume')
            const rawData = await response.json()
            const mappedData = mapCvDataToSections(rawData)
            
            setPortfolioData(mappedData)
            setHeroData(mappedData.hero || heroData)
            
            const visibility = {}
            const order = []
            mappedData.sections?.forEach(section => {
              visibility[section.id] = true
              order.push(section.id)
            })
            setSectionVisibility(visibility)
            setSectionsOrder(order)
            
            console.log('âœ… CV data loaded successfully')
        console.log('ðŸ“Š All sections data:', mappedData.sections.map(s => ({ 
          id: s.id, 
          type: s.type, 
          title: s.title, 
          dataLength: Array.isArray(s.data) ? s.data.length : 'not array',
          firstItem: Array.isArray(s.data) && s.data.length > 0 ? s.data[0] : 'no data'
        })))
          } catch (apiError) {
            console.log('â„¹ï¸ Error loading CV data, using demo content')
            // Keep using demo data that's already loaded
          }
        }
      } catch (err) {
        console.log('â„¹ï¸ Error in data loading, using demo content')
        // Keep using demo data that's already loaded
      } finally {
        setIsLoading(false)
      }
    }

    loadCVData()
  }, [])

  // Listen for messages from parent window
  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      // Only accept messages from parent window
      if (event.source !== window.parent) return
      
      if (event.data?.type === 'CHANGE_THEME') {
        const themeId = event.data.themeId
        // v2.1 uses theme names directly
        const themeMap: Record<string, string> = {
          'purple': 'purple',
          'blue': 'blue',
          'green': 'green',
          'yellow': 'yellow',
          'orange': 'orange',
          'pink': 'pink'
        }
        
        const themeName = themeMap[themeId] || 'purple'
        // The theme context in v2.1 handles theme changes
        window.localStorage.setItem('portfolio-theme', themeName)
        window.location.reload() // Simple reload to apply theme
      } else if (event.data?.type === 'TOGGLE_SECTION') {
        const { section, visible } = event.data
        setSectionVisibility(prev => ({ ...prev, [section]: visible }))
      } else if (event.data?.type === 'ADD_ITEM') {
        const { section, item } = event.data
        // This would need to be implemented per section
        console.log('Add item to section:', section, item)
      } else if (event.data?.type === 'UPDATE_CONTENT') {
        const { sectionId, content } = event.data
        // This would need to be implemented per section
        console.log('Update content:', sectionId, content)
      }
    }
    
    window.addEventListener('message', handleMessage)
    return () => window.removeEventListener('message', handleMessage)
  }, [])

  // Scroll tracking effect - simple pattern like v1.5
  useEffect(() => {
    if (isLoading) return

    const handleScroll = () => {
      const scrollPosition = window.scrollY + window.innerHeight / 2
      let currentSection = ""

      for (const sectionId of sectionsOrder) {
        if (sectionVisibility[sectionId]) {
          const element = document.getElementById(sectionId)
          if (element && element.offsetTop <= scrollPosition) {
            currentSection = sectionId
          }
        }
      }
      setActiveSection(currentSection)
    }

    window.addEventListener("scroll", handleScroll)
    handleScroll() // Set initial active section

    return () => window.removeEventListener("scroll", handleScroll)
  }, [isLoading])

  const handleDragEnd = (event) => {
    const { active, over } = event
    if (active.id !== over.id) {
      setSectionsOrder((items) => {
        const oldIndex = items.indexOf(active.id)
        const newIndex = items.indexOf(over.id)
        return arrayMove(items, oldIndex, newIndex)
      })
    }
  }

  const toggleSection = (sectionId: string) => {
    setSectionVisibility((prev) => ({
      ...prev,
      [sectionId]: !prev[sectionId],
    }))
  }
  
  const updateSectionData = (sectionId: string, newData: any) => {
    console.log('Updating section data:', sectionId, newData)
    setPortfolioData(prev => {
      if (!prev) return prev
      return {
        ...prev,
        sections: prev.sections.map(section => 
          section.id === sectionId 
            ? { ...section, data: newData }
            : section
        )
      }
    })
  }

  const sectionWrapperAnimation = {
    initial: { opacity: 0, height: 0, y: 20 },
    animate: { opacity: 1, height: "auto", y: 0, transition: { duration: 0.4, ease: "easeInOut" } },
    exit: { opacity: 0, height: 0, y: -20, transition: { duration: 0.3, ease: "easeInOut" } },
    className: "overflow-hidden",
  }

  const renderSection = (section) => {
    const Component = sectionComponentMap[section.type]
    if (!Component) {
      console.warn(`No component found for section type: ${section.type}`)
      return null
    }
    
    // Debug logging for paragraph sections
    if (section.type === 'paragraph') {
      console.log('Rendering paragraph section:', {
        id: section.id,
        title: section.title,
        data: section.data,
        dataType: typeof section.data,
        dataKeys: section.data ? Object.keys(section.data) : 'undefined'
      })
    }
    
    // For paragraph sections, ensure we handle the data correctly
    if (section.type === 'paragraph' && section.data && typeof section.data === 'object') {
      const props = {
        id: section.id,
        title: section.title,
        description: section.data.description || ''
      }
      return <Component {...props} />
    }
    
    // Default handling for other section types
    const props = { 
      id: section.id, 
      title: section.title, 
      items: section.data, 
      ...section.data,
      // Add onDataChange callback for timeline sections
      ...(section.type === 'timeline' ? { 
        onDataChange: (newData) => updateSectionData(section.id, newData) 
      } : {})
    }
    return <Component {...props} />
  }

  if (isLoading) {
    return (
      <div className="w-screen h-screen flex items-center justify-center bg-background">
        <Loader2 className="h-12 w-12 text-foreground animate-spin" />
      </div>
    )
  }

  return (
    <main className="bg-background antialiased">
      <EditModeToggle />
      <ThemeToggle />
      <ColorModeToggle />
      {/* Add padding when edit mode is active to account for the edit bar */}
      <motion.div
        animate={{ paddingTop: isEditMode ? "52px" : "0px" }}
        transition={{ duration: 0.3, ease: "easeInOut" }}
      >
      <FloatingNav navItems={navItems} activeSection={activeSection} />
      {!isEditMode && (
        <WatermarkToggle isVisible={isWatermarkVisible} onToggle={toggleWatermark} />
      )}
      {isEditMode && (
        <ExportButton 
          data={{
            hero: heroData,
            sections: portfolioData?.sections || [],
            sectionVisibility,
            sectionsOrder
          }}
        />
      )}
      <SectionControls isEditMode={isEditMode} />
      <WavyBackground
        colors={wavyColors}
        containerClassName="h-screen"
        className="h-full flex flex-col justify-start items-center"
        waveOpacity={1}
      >
        <motion.div className="text-center pt-12 md:pt-16 lg:pt-20 px-4" variants={heroContainerVariants} initial="hidden" animate="visible">
          {isEditMode ? (
            <>
              <EditableText
                as="h1"
                initialValue={heroData.name}
                onSave={(value) => setHeroData(prev => ({ ...prev, name: value }))}
                className={cn("text-foreground my-0 py-0 font-extrabold tracking-tighter", getSizeClasses("heroName"))}
              />
              <motion.div variants={heroTitleVariants} className="mt-4 relative">
                <div className={cn("absolute inset-0 bg-gradient-to-r blur-2xl", heroGradientClasses.glow)} />
                <EditableText
                  as="h2"
                  initialValue={heroData.title}
                  onSave={(value) => setHeroData(prev => ({ ...prev, title: value }))}
                  className={cn(
                    "relative font-medium uppercase tracking-[0.3em] text-2xl md:text-3xl lg:text-4xl",
                    "bg-gradient-to-r bg-clip-text text-transparent",
                    heroGradientClasses.gradient,
                    "drop-shadow-lg dark:drop-shadow-lg",
                    heroGradientClasses.shadow,
                    getSizeClasses("heroTitle"),
                  )}
                />
              </motion.div>
            </>
          ) : (
            <>
              <TextGenerateEffect
                words={heroData.name || ""}
                className={cn("text-foreground my-0 py-0 font-extrabold tracking-tighter", getSizeClasses("heroName"))}
              />
              <motion.div variants={heroTitleVariants} className="mt-4 relative">
                <div className={cn("absolute inset-0 bg-gradient-to-r blur-2xl", heroGradientClasses.glow)} />
                <AnimatedSubtitle
                  words={heroData.title || ""}
                  className={cn(
                    "relative font-medium uppercase tracking-[0.3em] text-2xl md:text-3xl lg:text-4xl",
                    "bg-gradient-to-r bg-clip-text text-transparent",
                    heroGradientClasses.gradient,
                    "drop-shadow-lg dark:drop-shadow-lg",
                    heroGradientClasses.shadow,
                    getSizeClasses("heroTitle"),
                  )}
                />
              </motion.div>
            </>
          )}
          <motion.div 
            variants={{
              hidden: { 
                y: 40, 
                opacity: 0,
                scale: 0.8,
                rotate: -10
              },
              visible: {
                y: 0,
                opacity: 1,
                scale: 1,
                rotate: 0,
                transition: {
                  duration: 1,
                  ease: [0.16, 1, 0.3, 1],
                  delay: 0.6
                },
              },
            }}
            className="mt-12 md:mt-16"
          >
            <AdvancedProfileEditor
              initialPhotoUrl={heroData.profilePhotoUrl}
              onPhotoChange={(url, settings) => setHeroData(prev => ({ 
                ...prev, 
                profilePhotoUrl: url,
                profilePhotoSettings: settings || prev.profilePhotoSettings
              }))}
              name={heroData.name}
              initialSettings={heroData.profilePhotoSettings}
            />
          </motion.div>
          
          {/* Hero Action Buttons */}
          <motion.div
            variants={{
              hidden: { y: 40, opacity: 0 },
              visible: {
                y: 0,
                opacity: 1,
                transition: {
                  duration: 0.8,
                  ease: [0.16, 1, 0.3, 1],
                  delay: 0.8
                }
              }
            }}
            className="mt-12 md:mt-16 lg:mt-20 flex flex-col sm:flex-row gap-6 md:gap-8 items-center justify-center px-4"
          >
            {/* Download CV Button */}
            <motion.div
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
              className="relative group"
            >
              <div className={cn("absolute inset-0 bg-gradient-to-r rounded-full blur-md opacity-75 group-hover:opacity-100 transition-opacity duration-300", heroGradientClasses.buttonGlow)} />
              <Button
                onClick={async () => {
                  const success = await downloadCV(`${heroData.name || 'CV'}.pdf`);
                  if (!success) {
                    // In a real app, you might want to show a toast notification
                    console.log('CV download not available');
                  }
                }}
                className={cn(
                  "relative px-8 py-5 md:px-12 md:py-7 lg:px-14 lg:py-8 rounded-full w-full sm:w-auto",
                  "bg-gradient-to-r",
                  heroGradientClasses.buttonGradient,
                  "text-white font-bold text-lg md:text-xl",
                  "shadow-lg hover:shadow-xl",
                  "border-0",
                  "transition-all duration-300",
                  getSizeClasses("button")
                )}
              >
                <span className="flex items-center gap-4">
                  <Download className="w-6 h-6 md:w-7 md:h-7" />
                  Download CV
                </span>
              </Button>
            </motion.div>

            {/* Availability Status Button with Scroll */}
            <motion.div
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
              className="relative group"
            >
              <EditableAvailability
                initialAvailability={heroData.availability || "Available for opportunities"}
                onAvailabilityChange={(availability) => setHeroData(prev => ({ ...prev, availability }))}
                fontSize={getSizeClasses("button")}
              />
            </motion.div>
          </motion.div>
        </motion.div>
      </WavyBackground>
      <TracingBeam className="px-0 overflow-visible">
        <motion.div 
          className="w-full max-w-none lg:max-w-7xl mx-auto antialiased pt-4 relative space-y-16 md:space-y-20 lg:space-y-28 overflow-visible px-4 sm:px-6 lg:px-8"
          layout
          transition={{ duration: 0.3, ease: "easeInOut" }}>
          {isEditMode ? (
            <DndContext 
              sensors={sensors} 
              collisionDetection={closestCenter} 
              onDragEnd={(event: DragEndEvent) => {
                const { active, over } = event
                if (active.id !== over?.id) {
                  setSectionsOrder((items) => {
                    const oldIndex = items.indexOf(active.id as string)
                    const newIndex = items.indexOf(over?.id as string)
                    return arrayMove(items, oldIndex, newIndex)
                  })
                }
              }}
            >
              <SortableContext items={sectionsOrder} strategy={verticalListSortingStrategy}>
                <AnimatePresence>
                  {sectionsOrder.map((sectionId) => {
                    const section = portfolioData?.sections.find((s) => s.id === sectionId)
                    if (!section || !sectionVisibility[section.id]) return null
                    return (
                      <DraggableSection key={section.id} id={section.id}>
                        <motion.div data-section-id={section.id} {...sectionWrapperAnimation}>
                          {renderSection(section)}
                        </motion.div>
                      </DraggableSection>
                    )
                  })}
                </AnimatePresence>
              </SortableContext>
            </DndContext>
          ) : (
            <AnimatePresence>
              {sectionsOrder.map((sectionId) => {
                const section = portfolioData?.sections.find((s) => s.id === sectionId)
                if (!section || !sectionVisibility[section.id]) return null
                return (
                  <motion.div key={section.id} data-section-id={section.id} {...sectionWrapperAnimation}>
                    {renderSection(section)}
                  </motion.div>
                )
              })}
            </AnimatePresence>
          )}
        </motion.div>
      </TracingBeam>
      </motion.div>
    </main>
  )
}
